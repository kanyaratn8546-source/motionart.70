<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>rerofya - Serene Living Garden</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,700;1,700&family=Inter:wght@300;400&display=swap');

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            background: #01040a; 
            overflow: hidden; 
            touch-action: none; 
            font-family: 'Inter', sans-serif;
            cursor: pointer;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; 
        }

        /* กรอบวิดีโอทรงแคปซูล Pill-shaped */
        .video-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90vw;
            max-width: 850px;
            height: auto; 
            z-index: 50;
            background: #000; 
            border: 2px solid rgba(56, 189, 248, 0.4); 
            border-radius: 60px; 
            padding: 10px;
            transition: all 1.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 40px rgba(56, 189, 248, 0.25), inset 0 0 20px rgba(56, 189, 248, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .video-container.is-playing {
            border-color: rgba(56, 189, 248, 0.7);
            box-shadow: 0 0 60px rgba(56, 189, 248, 0.4), inset 0 0 30px rgba(56, 189, 248, 0.2);
        }

        .video-content {
            position: relative;
            width: 100%;
            height: 100%;
            border-radius: 50px;
            overflow: hidden;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .video-content video {
            width: 100%;
            height: auto;
            display: block;
            border-radius: 50px;
            opacity: 0.6;
            transition: opacity 0.8s ease;
        }

        .video-container.is-playing video {
            opacity: 0.9;
        }

        /* ส่วนควบคุมวิดีโอ */
        .controls-overlay {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: clamp(20px, 8vw, 60px);
            z-index: 60;
            opacity: 1;
            transition: opacity 0.5s cubic-bezier(0.4, 0, 0.2, 1), background 0.5s ease;
            background: rgba(0, 0, 0, 0.45);
            pointer-events: auto;
        }

        .video-container.is-playing:not(.show-ui) .controls-overlay {
            opacity: 0;
            background: rgba(0, 0, 0, 0);
            pointer-events: none;
        }

        .video-container.show-ui .controls-overlay {
            opacity: 1 !important;
            background: rgba(0, 0, 0, 0.5) !important;
            pointer-events: auto !important;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            color: white;
            cursor: pointer;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            -webkit-tap-highlight-color: transparent;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.15);
            border-color: rgba(56, 189, 248, 0.6);
        }

        .play-btn { width: 85px; height: 85px; }
        .skip-btn { width: 55px; height: 55px; }
        .control-btn svg { fill: currentColor; width: 45%; height: 45%; }

        @media (max-width: 640px) {
            .video-container { border-radius: 40px; width: 92vw; padding: 6px; }
            .play-btn { width: 70px; height: 70px; }
            .skip-btn { width: 45px; height: 45px; }
        }
    </style>
</head>
<body>

    <canvas id="vineCanvas"></canvas>

    <div class="video-container" id="videoContainer">
        <div class="video-content">
            <!-- นำ attribute 'muted' ออกเพื่อให้มีเสียง -->
            <video id="mainVideo" playsinline loop>
                <source src="https://image2url.com/r2/default/videos/1770011487986-c14c73dd-4250-41f3-9f5c-cc4bd2749ab4.mp4" type="video/mp4">
            </video>
            
            <div class="controls-overlay" id="controlsOverlay">
                <div class="control-btn skip-btn" id="rewindBtn" title="Back 10s">
                    <svg viewBox="0 0 24 24"><path d="M12.5 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1.5 11h1v-4h-1v4zm2.5-4v4h3v-4h-3z"/></svg>
                </div>
                <div class="control-btn play-btn" id="playBtnUI">
                    <svg id="playIcon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                </div>
                <div class="control-btn skip-btn" id="forwardBtn" title="Forward 10s">
                    <svg viewBox="0 0 24 24"><path d="M11.5 3c4.97 0 9 4.03 9 9H23l-3.89 3.89-.07.14L15 12h3c0-3.87-3.13-7-7-7s-7 3.13-7 7 3.13 7 7 7c1.93 0 3.68-.79 4.94-2.06l1.42 1.42C15.73 19.99 13.49 21 11 21c-4.97 0-9-4.03-9-9s4.03-9 9-9zm1.5 11h-1v-4h1v4zm-2.5-4v4h-3v-4h3z"/></svg>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('vineCanvas');
        const ctx = canvas.getContext('2d', { alpha: true });
        const video = document.getElementById('mainVideo');
        const container = document.getElementById('videoContainer');
        const playIcon = document.getElementById('playIcon');
        
        let uiTimeout;
        let vines = [];
        let stars = [];
        let fireflies = [];
        let globalTime = 0;

        // --- Perlin Noise ---
        class PerlinNoise {
            constructor() {
                this.p = [];
                for (let i = 0; i < 512; i++) this.p[i] = Math.floor(Math.random() * 256);
            }
            fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            lerp(t, a, b) { return a + t * (b - a); }
            grad(hash, x) {
                const h = hash & 15;
                const grad = 1 + (h & 7);
                return ((h & 8) ? -grad : grad) * x;
            }
            noise(x) {
                const X = Math.floor(x) & 255;
                x -= Math.floor(x);
                const u = this.fade(x);
                return this.lerp(u, this.grad(this.p[X], x), this.grad(this.p[X + 1], x - 1)) * 0.5 + 0.5;
            }
        }
        const perlin = new PerlinNoise();

        function initEvents() {
            // คลิกที่พื้นหลังหรือตัววิดีโอเพื่อ Play/Pause
            document.body.addEventListener('click', (e) => {
                // ถ้าคลิกโดนปุ่มควบคุมย่อย ไม่ต้องรันซ้ำ
                if (e.target.closest('.control-btn')) return;
                togglePlay();
            });

            document.getElementById('playBtnUI').addEventListener('click', (e) => {
                e.stopPropagation(); 
                togglePlay();
            });

            const showUI = () => {
                container.classList.add('show-ui');
                clearTimeout(uiTimeout);
                if (!video.paused) {
                    uiTimeout = setTimeout(() => {
                        container.classList.remove('show-ui');
                    }, 2500);
                }
            };

            window.addEventListener('mousemove', showUI);
            window.addEventListener('touchstart', showUI);

            document.getElementById('rewindBtn').addEventListener('click', (e) => {
                e.stopPropagation(); video.currentTime -= 10; showUI();
            });
            document.getElementById('forwardBtn').addEventListener('click', (e) => {
                e.stopPropagation(); video.currentTime += 10; showUI();
            });

            video.addEventListener('ended', () => {
                container.classList.remove('is-playing');
                container.classList.add('show-ui');
                updatePlayIcon(false);
            });
        }

        async function togglePlay() {
            if (video.ended) video.currentTime = 0;
            
            if (video.paused) {
                try {
                    // การเรียก play() หลังจาก user interaction (click) จะทำให้เสียงดังได้ปกติ
                    await video.play();
                    container.classList.add('is-playing');
                    container.classList.remove('show-ui');
                    clearTimeout(uiTimeout);
                    updatePlayIcon(true);
                    
                    // เอฟเฟกต์เถาวัลย์
                    for(let i=0; i<12; i++) setTimeout(() => spawnFromVideo(true), i * 100);
                } catch (err) {
                    console.error("Playback failed:", err);
                }
            } else {
                video.pause();
                container.classList.remove('is-playing');
                container.classList.add('show-ui');
                updatePlayIcon(false);
            }
        }

        function updatePlayIcon(isPlaying) {
            playIcon.innerHTML = isPlaying 
                ? '<path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>' 
                : '<path d="M8 5v14l11-7z"/>';
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initStars();
            initFireflies();
        }
        window.addEventListener('resize', resize);

        function initStars() {
            stars = [];
            for (let i = 0; i < 150; i++) {
                stars.push({
                    x: Math.random() * canvas.width, y: Math.random() * canvas.height,
                    size: Math.random() * 1.5, opacity: Math.random() * 0.7,
                    phase: Math.random() * Math.PI * 2, speed: 0.0008
                });
            }
        }

        function initFireflies() {
            fireflies = [];
            for (let i = 0; i < 30; i++) {
                fireflies.push({
                    x: Math.random() * canvas.width, y: Math.random() * canvas.height,
                    s: Math.random() * 2 + 0.5, vx: (Math.random()-0.5)*0.4, vy: (Math.random()-0.5)*0.4,
                    offset: Math.random() * 5000, color: '#38bdf8'
                });
            }
        }

        const leafColors = ['#15b097', '#0e8a75', '#1ba38e', '#065f46'];
        const vineColors = ['#0a1a1a', '#0f2626', '#134e4a'];

        class Vine {
            constructor(x, y, baseAngle, width, maxLenFactor = 1.0, generation = 0) {
                this.x = x; this.y = y; this.baseAngle = baseAngle; this.angle = baseAngle;
                this.startWidth = width; this.generation = generation;
                this.maxLen = (Math.random() * 180 + 160) * maxLenFactor;
                this.curLen = 0;
                this.points = [{ x, y, w: width, angle: baseAngle }];
                this.color = vineColors[Math.floor(Math.random() * vineColors.length)];
                this.opacity = 0;
                this.state = 'growing';
                this.waitTimer = 0;
                this.maxWait = 8000 + Math.random() * 8000;
                this.leaves = []; this.flowers = [];
                this.noiseOffset = Math.random() * 10000;
                this.noiseScale = 0.012;
                this.growthSpeed = 1.0 + Math.random() * 0.5;
                this.gravity = 0.0006;
                this.windSense = 0.18 + Math.random() * 0.1;
                this.windPhase = Math.random() * 10;
            }

            update() {
                if (this.state === 'growing') {
                    if (this.opacity < 0.8) this.opacity += 0.04;
                    if (this.curLen < this.maxLen) {
                        const noiseVal = perlin.noise(this.curLen * this.noiseScale + this.noiseOffset);
                        this.angle += (noiseVal - 0.5) * 0.45 + this.gravity * (this.curLen * 0.06);
                        
                        const step = this.growthSpeed;
                        this.x += Math.cos(this.angle) * step;
                        this.y += Math.sin(this.angle) * step;

                        let currentW = this.startWidth * Math.pow(1 - (this.curLen / this.maxLen), 0.75);
                        this.points.push({ x: this.x, y: this.y, w: currentW, angle: this.angle });
                        this.curLen += step;

                        if (this.generation < 1 && this.curLen > 80 && Math.random() > 0.985) this.spawnBranch();
                        if (Math.random() > 0.92) this.addLeaf(this.points.length - 1);
                        if (this.generation === 0 && Math.random() > 0.997) this.addFlower(this.points.length - 1);
                    } else { this.state = 'living'; }
                } else if (this.state === 'living') {
                    if (++this.waitTimer > this.maxWait) this.state = 'fading';
                } else if (this.state === 'fading') {
                    this.opacity -= 0.005;
                    if (this.opacity <= 0) return true;
                }
                return false;
            }

            spawnBranch() {
                const p = this.points[this.points.length - 1];
                const branchAngle = this.angle + (Math.random() - 0.5) * 1.8;
                vines.push(new Vine(p.x, p.y, branchAngle, p.w * 0.75, 0.5, this.generation + 1));
            }

            addLeaf(pIdx) {
                const side = Math.random() > 0.5 ? 1 : -1;
                this.leaves.push({
                    pIdx, angle: (Math.PI / 2.3) * side, size: 0,
                    targetSize: Math.random() * 7 + 4,
                    color: leafColors[Math.floor(Math.random() * leafColors.length)],
                    jitter: Math.random() * 5
                });
            }

            addFlower(pIdx) {
                this.flowers.push({ pIdx, size: 0, targetSize: Math.random() * 6 + 4, rot: Math.random() * Math.PI * 2 });
            }

            draw() {
                if (this.opacity <= 0) return;
                ctx.globalAlpha = this.opacity;
                const windTime = globalTime * 0.0012;

                if (this.points.length > 3) {
                    ctx.lineCap = 'round'; ctx.strokeStyle = this.color; ctx.beginPath();
                    ctx.moveTo(this.points[0].x, this.points[0].y);
                    for (let j = 1; j < this.points.length - 2; j++) {
                        const p = this.points[j];
                        const nextP = this.points[j+1];
                        const ratio = j / this.points.length;
                        const sway = Math.sin(windTime - j * 0.06 + this.windPhase) * (ratio * ratio * 40 * this.windSense);
                        const midX = (p.x + nextP.x) / 2 + sway * Math.cos(p.angle + 1.57);
                        const midY = (p.y + nextP.y) / 2 + sway * Math.sin(p.angle + 1.57);
                        ctx.lineWidth = p.w;
                        ctx.quadraticCurveTo(p.x + sway * Math.cos(p.angle + 1.57), p.y + sway * Math.sin(p.angle + 1.57), midX, midY);
                    }
                    ctx.stroke();
                }

                this.leaves.forEach(l => {
                    const p = this.points[l.pIdx];
                    if (!p) return;
                    const ratio = l.pIdx / this.points.length;
                    const sway = Math.sin(windTime - l.pIdx * 0.06 + this.windPhase) * (ratio * ratio * 40 * this.windSense);
                    if (this.state !== 'fading' && l.size < l.targetSize) l.size += 0.25;
                    ctx.save();
                    ctx.translate(p.x + sway * Math.cos(p.angle + 1.57), p.y + sway * Math.sin(p.angle + 1.57));
                    ctx.rotate(p.angle + l.angle + Math.sin(globalTime * 0.006 + l.jitter) * 0.12);
                    const s = l.size;
                    ctx.beginPath(); ctx.moveTo(0, 0); 
                    ctx.bezierCurveTo(-s, -s, -s * 1.5, s * 0.5, 0, s); 
                    ctx.bezierCurveTo(s * 1.5, s * 0.5, s, -s, 0, 0);
                    ctx.fillStyle = l.color; ctx.fill();
                    ctx.restore();
                });

                this.flowers.forEach(f => {
                    const p = this.points[f.pIdx];
                    if (!p) return;
                    const ratio = f.pIdx / this.points.length;
                    const sway = Math.sin(windTime - f.pIdx * 0.06 + this.windPhase) * (ratio * ratio * 40 * this.windSense);
                    if (this.state !== 'fading' && f.size < f.targetSize) f.size += 0.15;
                    ctx.save();
                    ctx.translate(p.x + sway * Math.cos(p.angle + 1.57), p.y + sway * Math.sin(p.angle + 1.57));
                    ctx.rotate(f.rot + globalTime * 0.0008);
                    ctx.fillStyle = "rgba(255, 255, 255, 0.98)";
                    for (let n = 0; n < 5; n++) {
                        ctx.rotate((Math.PI * 2) / 5);
                        ctx.beginPath(); ctx.ellipse(f.size * 1.3, 0, f.size, f.size * 0.7, 0, 0, Math.PI * 2); ctx.fill();
                    }
                    ctx.beginPath(); ctx.arc(0, 0, f.size * 0.6, 0, Math.PI * 2); ctx.fillStyle = "#fcd34d"; ctx.fill();
                    ctx.restore();
                });
            }
        }

        function spawnFromVideo(force = false) {
            if (!force && (video.paused || video.ended)) return;
            if (vines.length > 45) return; 

            const rect = container.getBoundingClientRect();
            const side = Math.floor(Math.random() * 4); 
            let startX, startY, startAngle;
            const spread = (Math.random() - 0.5) * 1.5;

            if (side === 0) { // บน
                startX = rect.left + Math.random() * rect.width; startY = rect.top + 8; startAngle = -Math.PI/2 + spread;
            } else if (side === 1) { // ขวา
                startX = rect.right - 8; startY = rect.top + Math.random() * rect.height; startAngle = spread;
            } else if (side === 2) { // ล่าง
                startX = rect.left + Math.random() * rect.width; startY = rect.bottom - 8; startAngle = Math.PI/2 + spread;
            } else { // ซ้าย
                startX = rect.left + 8; startY = rect.top + Math.random() * rect.height; startAngle = Math.PI + spread;
            }
            vines.push(new Vine(startX, startY, startAngle, 1.5));
        }

        function animate(time) {
            globalTime = time;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#01040a'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            stars.forEach(s => {
                ctx.globalAlpha = s.opacity * (0.3 + Math.sin(time * s.speed + s.phase) * 0.7);
                ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2); ctx.fill();
            });

            fireflies.forEach(f => {
                f.x += f.vx + Math.sin(time * 0.0006 + f.offset) * 0.5;
                f.y += f.vy + Math.cos(time * 0.0006 + f.offset) * 0.5;
                if (f.x < -30) f.x = canvas.width + 30; else if (f.x > canvas.width + 30) f.x = -30;
                if (f.y < -30) f.y = canvas.height + 30; else if (f.y > canvas.height + 30) f.y = -30;
                ctx.globalAlpha = 0.4 + Math.sin(time * 0.003 + f.offset) * 0.6;
                ctx.fillStyle = f.color; ctx.beginPath(); ctx.arc(f.x, f.y, f.s, 0, Math.PI * 2); ctx.fill();
            });

            ctx.globalAlpha = 1;
            for (let i = vines.length - 1; i >= 0; i--) {
                if (vines[i].update()) vines.splice(i, 1);
                else vines[i].draw();
            }
            requestAnimationFrame(animate);
        }

        window.onload = () => {
            resize(); 
            initEvents(); 
            animate(0);
            
            // Spawn เถาวัลย์เริ่มต้น
            for(let i=0; i<8; i++) setTimeout(() => spawnFromVideo(true), i * 250);
            
            // Loop spawn อัตโนมัติเมื่อวิดีโอเล่น
            setInterval(() => spawnFromVideo(false), 2200); 
        };
    </script>
</body>
</html>
